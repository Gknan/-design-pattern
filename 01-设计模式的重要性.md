### 1、设计模式的重要性

1）是对软件设计中普遍存在（反复出现）的问题所提出的解决方案。

2）软件复用，代码重用，扩展性，可读性，规范性，可维护性

3）设计模式在软件中哪里（面向对象分析--功能模块（设计模式+数据结构）--框架（多种设计模式）--架构【服务器集群】）

4）面试中：**用了什么设计模式？怎么用的？解决了什么问题？**

### 2、设计模式特点

1）设计模式站在软件结构上思考问题的，不是站在功能实现上考虑

2）应用场景 -> 设计模式 -> 剖析原理 -> 分析实现步骤（图解）->代码 -> 框架或项目源码分析（找到使用的地方）

### 3、设计模式的目的

编程中面临的问题：耦合性、内聚性、可维护性、可扩展性、重用性、灵活性的挑战。设计模式为了让程序具有更好的：
1）代码重用性（相同功能的代码不用多次编写）

2）可读性（编程规范性，便于其他程序员的阅读和理解）

3）可扩展性（当需要增加新的功能时，成本低，也成为可维护性）

4）可靠性（增加新的功能后，对原来的功能没有影响）

5）使程序呈现**高内聚、低耦合**的特性

### 4、设计模式的七大原则 -- 设计模式为何这么设计的依据

#### 1）单一职责

**含义**：一个类应该值负责一项职责

**单一职责案例**

方式1，交通工具类 天上 水中 公路

```java
public class SingleResponsibility1 {

    public static void main(String[] args) {
        Vehicle vehicle = new Vehicle();

        vehicle.run("自行车");
        vehicle.run("摩托车");
        vehicle.run("潜艇");
        vehicle.run("飞机");
    }
}

class Vehicle {

    public void run(String vehicle) {
        System.out.println(vehicle + "正在公路上跑");
    }
}
```

方式2，按照类分解

```java
public class SingleResponsibility2 {

    public static void main(String[] args) {

        RoadVehicle roadVehicle = new RoadVehicle();
        WaterVehicle waterVehicle = new WaterVehicle();
        AirVehicle airVehicle = new AirVehicle();

        roadVehicle.run("自行车");
        roadVehicle.run("摩托车");
        waterVehicle.run("潜艇");
        airVehicle.run("飞机");
    }
}

/*
根据单一职责按照类划分
优点是完全遵循单一职责
缺点是代码改动大，客户端，功能代码均改动
 */
class RoadVehicle {

    void run(String vehicle) {
        System.out.println(vehicle + "正在公路上跑");
    }
}

class WaterVehicle {

    void run(String vehicle) {
        System.out.println(vehicle + "正在水上跑");
    }
}

class AirVehicle {

    void run(String vehicle) {
        System.out.println(vehicle + "正在天空上跑");
    }
}
```

方式3，类级别没有遵守单一职责，方法级别上遵守单一职责

```java
public class SingleResponsibility3 {

    public static void main(String[] args) {
        NewVehicle vehicle = new NewVehicle();

        vehicle.runRoad("自行车");
        vehicle.runRoad("摩托车");
        vehicle.runWater("潜艇");
        vehicle.runAir("飞机");
    }
}

/*
没有在累级别遵循单一职责，方法级别的遵守
在类足够简单且类中方法足够少时可用
 */
class NewVehicle {

    public void runRoad(String vehicle) {
        System.out.println(vehicle + "正在公路上跑");
    }

    public void runWater(String vehicle) {
        System.out.println(vehicle + "正在水上跑");
    }

    public void runAir(String vehicle) {
        System.out.println(vehicle + "正在天上跑");
    }
}
```

**细节：**

* 通常情况下，应该严格遵守单一职责，只要代码足够简单时，类中方案足够少，才可违反

* 提高类的可读性，可维护性

* 降低变更引起的风险

* 降低类的复杂性

#### 2）接口隔离

介绍：客户端不应该依赖不需要的接口。一个类对另一个类的依赖应2建立在最小的接口上。

案例：类A通过接口依赖B，类C通过接口依赖D

```java
public class InterfaceSegment2 {
}

interface Interface1 {
    public void opration1();
}

interface Interface2 {
    public void opration2();
    public void opration3();
}

interface Interface3 {
    public void opration4();
    public void opration5();
}


// 类 A 通过 接口依赖 B（使用 B）
class A {
    private void operation1(B interface1) {
        interface1.opration1();
    }

    private void operation2(B interface1) {
        interface1.opration2();
    }

    private void operation3(B interface1) {
        interface1.opration3();
    }
}

class B implements Interface1, Interface2 {
    @Override
    public void opration1() {
        System.out.println("B 实现了 opration1");
    }

    @Override
    public void opration2() {
        System.out.println("B 实现了 opration2");
    }

    @Override
    public void opration3() {
        System.out.println("B 实现了 opration3");
    }
}

class C {
    public void operation1(D interface1) {
        interface1.opration1();
    }

    public void operation4(D interface1) {
        interface1.opration4();
    }

    public void operation5(D interface1) {
        interface1.opration5();
    }
}

class D implements Interface1, Interface3 {

    @Override
    public void opration1() {
        System.out.println("D 实现了 opration1");
    }

    @Override
    public void opration4() {
        System.out.println("D 实现了 opration4");
    }

    @Override
    public void opration5() {
        System.out.println("D 实现了 opration5");
    }
}
```

隔离依赖，拆分接口

```java
public class InterfaceSegment2 {
}

interface Interface1 {
    public void opration1();
}

interface Interface2 {
    public void opration2();
    public void opration3();
}

interface Interface3 {
    public void opration4();
    public void opration5();
}


// 类 A 通过 接口依赖 B（使用 B）
class A {
    private void operation1(B interface1) {
        interface1.opration1();
    }

    private void operation2(B interface1) {
        interface1.opration2();
    }

    private void operation3(B interface1) {
        interface1.opration3();
    }
}

class B implements Interface1, Interface2 {
    @Override
    public void opration1() {
        System.out.println("B 实现了 opration1");
    }

    @Override
    public void opration2() {
        System.out.println("B 实现了 opration2");
    }

    @Override
    public void opration3() {
        System.out.println("B 实现了 opration3");
    }
}

class C {
    public void operation1(D interface1) {
        interface1.opration1();
    }

    public void operation4(D interface1) {
        interface1.opration4();
    }

    public void operation5(D interface1) {
        interface1.opration5();
    }
}

class D implements Interface1, Interface3 {

    @Override
    public void opration1() {
        System.out.println("D 实现了 opration1");
    }

    @Override
    public void opration4() {
        System.out.println("D 实现了 opration4");
    }

    @Override
    public void opration5() {
        System.out.println("D 实现了 opration5");
    }
}
```

#### 3）依赖倒置

基本介绍

1. 高层模块不应该依赖底层模块，二者都应该依赖抽象
2. 抽象不应该依赖细节，细节应该依赖抽象
3. 依赖倒转的中心是面向接口编程
4. 抽象的东西相对稳定，变化少，以抽象搭建起来的架构稳定的多。抽象指的是接口或抽象类。细节值得是具体的实现类
5. 使用接口或抽象类的目的是指定好规范，而不涉及任何具体的操作，把展现细节的任务交给实现类完成

案例，实现 Person 类，具有接收消息的功能



#### 4）里氏替换原则

#### 5）开闭

#### 6）迪米特

#### 7）合成复用

